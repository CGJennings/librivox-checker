package ca.cgjennings.apps.librivox.decoder;

/**
 * A frame of sequential audio samples in 16-bit PCM format. An audio frame is a
 * passive container for data generated by a decoder. It insulates the rest of
 * the application from the particular decoder that is being used. Rather than
 * create a new frame object as each frame is read, a single instance is shared
 * and updated after each frame has been processed.
 *
 * <p>
 * The sample buffer will also be shared across all of the various
 * {@link AnalysisMethod}s. Therefore, the contents of the sample buffer should
 * never be written to. If a mutable buffer is required, clone the provided
 * buffer and mutate the contents of the clone.
 *
 * @author Christopher G. Jennings (cjennings@acm.org)
 */
public class AudioFrame {

    private ChannelFormat format;
    private int channels;
    private int frequency;
    private short[] samples;
    private int length;

    /**
     * Creates a new, uninitialized audio frame container. Before passing the
     * frame to a client, it must be initialized with appropriate data by
     * calling {@link #set}.
     */
    public AudioFrame() {
    }

    /**
     * Updates the frame object's state.
     *
     * @param chFormat a description of the channel format
     * @param frequency the sampling frequency in Hz
     * @param samples the audio data buffer
     * @param length the number of valid samples in the audio buffer
     */
    public void set(ChannelFormat chFormat, int frequency, short[] samples, int length) {
        if (chFormat == null) {
            throw new NullPointerException("chFormat");
        }
        if (frequency < 1) {
            throw new IllegalArgumentException("frequency must be positive: " + frequency);
        }
        if (samples == null) {
            throw new NullPointerException("samples");
        }
        if (length < 0) {
            throw new IllegalArgumentException("length must not be negative: " + length);
        }

        format = chFormat;
        this.channels = chFormat.getChannelCount();
        this.frequency = frequency;
        this.samples = samples;
        this.length = length / channels;

        // check that there are not more samples for one channel than another
        if (this.length * channels != length) {
            throw new AssertionError("one or more channels have an extra sample");
        }
    }

    /**
     * Returns the audio channel format (such as mono or stereo). Note that if
     * the channel format is <code>JOINT_STEREO</code>, this should be treated
     * as stereo as the samples will have been decoded appropriately.
     *
     * @return the channel format of the current frame
     */
    public ChannelFormat getChannelFormat() {
        return format;
    }

    /**
     * Returns the number of channels in the audio frame; normally expected to
     * be constant for an entire file.
     *
     * @return the number of channels (e.g., 1 for mono sound)
     */
    public int getChannelCount() {
        return channels;
    }

    /**
     * Returns the sampling frequency, in hertz.
     *
     * @return the sampling frequency
     */
    public int getFrequency() {
        return frequency;
    }

    /**
     * Returns a buffer of the frame's samples. The samples are interleaved,
     * starting with channel 0, and are in 16-bit PCM format. This means that
     * the <i>n</i>th sample for channel <i>k</i> is found at index
     * <i>nk</i> (where <i>n</i> and <i>k</i> are both indexes starting at 0).
     * <p>
     * The maximum valid index for this buffer is
     * <code>{@link #getChannelCount()} * {@link #getSampleCount()} - 1</code>.
     * Note that this may be less than <code>getSamples().length</code>
     *
     * @return an array of signed 16-bit sample data
     */
    public short[] getSamples() {
        return samples;
    }

    /**
     * Returns the number of samples for each channel that are available in the
     * buffer.
     *
     * @return the number of valid samples in the buffer
     * @see #getSamples()
     */
    public int getSampleCount() {
        return length;
    }

    /**
     * The maximum number of audio channels that may occur in an audio frame.
     * The value returned by {@link #getChannelCount()} must be between 1 and
     * <code>MAX_CHANNELS</code>.
     */
    public static final int MAX_CHANNELS = 2;
}
